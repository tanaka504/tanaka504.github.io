<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Round Generator</title>
  <!-- Bootstrap 5 CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
  --primary-color: #4e73df;
  --secondary-color: #1cc88a;
  --accent-color: #f6c23e;
  --danger-color: #e74a3b;
  --dark-color: #5a5c69;
  --light-color: #f8f9fc;
  --border-radius: 0.35rem;
  --card-shadow: 0 0.15rem 1.75rem 0 rgba(58, 59, 69, 0.15);
  --transition-speed: 0.3s;
}

body {
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(to right, #f8f9fa, #e9ecef);
  padding: 0;
  color: var(--dark-color);
}

.app-container {
  min-height: 100vh;
  padding: 1rem;
}

.header-section {
  background: white;
  padding: 1.5rem;
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
  margin-bottom: 1.5rem;
  position: relative;
  overflow: hidden;
}

.header-section::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 8px;
  height: 100%;
  background: var(--primary-color);
}

h1 {
  font-weight: 700;
  color: var(--primary-color);
  margin-bottom: 1rem;
  position: relative;
  display: inline-block;
  font-size: 1.75rem;
}

h1::after {
  content: "";
  position: absolute;
  left: 0;
  bottom: -8px;
  width: 50px;
  height: 4px;
  background: var(--secondary-color);
  border-radius: 2px;
}

.config-card {
  background: white;
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
  padding: 1.25rem;
  margin-bottom: 1.5rem;
  transition: transform var(--transition-speed);
}

.config-card:hover {
  transform: translateY(-2px);
}

.form-label {
  font-weight: 500;
  color: var(--dark-color);
  font-size: 0.9rem;
}

.form-control {
  border-radius: var(--border-radius);
  padding: 0.75rem 1rem;
  border: 1px solid #e3e6f0;
  transition: all var(--transition-speed);
  font-size: 1rem;
}

.form-control:focus {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 0.25rem rgba(78, 115, 223, 0.25);
}

.input-group-text {
  background-color: #f8f9fc;
  border-color: #e3e6f0;
  font-size: 0.9rem;
}

.btn {
  border-radius: var(--border-radius);
  padding: 0.75rem 1.5rem;
  font-weight: 600;
  transition: all var(--transition-speed);
  font-size: 0.95rem;
}

.btn-primary {
  background-color: var(--primary-color);
  border-color: var(--primary-color);
}

.btn-primary:hover {
  background-color: #2e59d9;
  border-color: #2653d4;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(46, 89, 217, 0.2);
}

.btn-secondary {
  background-color: var(--dark-color);
  border-color: var(--dark-color);
}

.btn-secondary:hover {
  background-color: #484b58;
  border-color: #444752;
}

.btn-icon {
  margin-right: 8px;
}

.results-card {
  background: white;
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
  padding: 0;
  overflow: hidden;
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.5s ease;
}

.results-card.show {
  opacity: 1;
  transform: translateY(0);
}

.results-header {
  background: var(--primary-color);
  color: white;
  padding: 1rem 1.25rem;
  font-weight: 600;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.stats-container {
  display: flex;
  flex-wrap: wrap;
  padding: 1rem;
  background: #f8f9fc;
  border-bottom: 1px solid #e3e6f0;
}

.stat-card {
  flex: 1;
  min-width: 150px;
  background: white;
  border-radius: var(--border-radius);
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  padding: 0.75rem;
  margin: 0.25rem;
  text-align: center;
  border-left: 4px solid var(--primary-color);
}

.stat-card.primary { border-left-color: var(--primary-color); }
.stat-card.success { border-left-color: var(--secondary-color); }
.stat-card.warning { border-left-color: var(--accent-color); }
.stat-card.danger { border-left-color: var(--danger-color); }

.stat-title {
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #858796;
  margin-bottom: 0.25rem;
}

.stat-value {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--dark-color);
}

.table-container {
  padding: 0.5rem;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

.table {
  margin-bottom: 0;
  border-collapse: separate;
  border-spacing: 0;
  min-width: 600px;
}

.table thead th {
  background-color: #f8f9fc;
  border-bottom: 1px solid #e3e6f0;
  font-weight: 600;
  color: #6e707e;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 0.75rem;
  padding: 0.75rem 0.5rem;
  white-space: nowrap;
}

.table tbody tr {
  transition: all var(--transition-speed);
}

.table tbody tr:hover {
  background-color: rgba(78, 115, 223, 0.05);
}

.table tbody td {
  padding: 0.75rem 0.5rem;
  vertical-align: middle;
  border-top: 1px solid #e3e6f0;
}

.round-badge {
  background: var(--primary-color);
  color: white;
  border-radius: 50px;
  padding: 0.25rem 0.75rem;
  font-weight: 600;
  display: inline-block;
  font-size: 0.8rem;
}

.court-badge {
  background: #f1f1f1;
  color: var(--dark-color);
  border-radius: 3px;
  padding: 0.25rem 0.5rem;
  font-size: 0.8rem;
  white-space: nowrap;
}

.team-container {
  display: flex;
  align-items: center;
  justify-content: flex-end;
}

.team-container.right {
  justify-content: flex-start;
}

.team-label {
  background: #e8f0fe;
  color: var(--primary-color);
  border-radius: 3px;
  padding: 0.25rem 0.5rem;
  font-weight: 600;
  font-size: 0.85rem;
  white-space: nowrap;
}

.vs-badge {
  background: #f8f9fc;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  color: var(--dark-color);
  margin: 0 0.5rem;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  font-size: 0.7rem;
  flex-shrink: 0;
}

.call-checkbox {
  transform: scale(1.2);
  accent-color: var(--primary-color);
  cursor: pointer;
}

.completed td {
  opacity: 0.5;
  text-decoration: line-through;
}

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s;
}

.loading-overlay.show {
  opacity: 1;
  visibility: visible;
}

.spinner {
  width: 50px;
  height: 50px;
  border: 5px solid rgba(78, 115, 223, 0.2);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem 1rem;
  text-align: center;
}

.empty-icon {
  font-size: 3rem;
  color: #d1d3e2;
  margin-bottom: 1rem;
}

.empty-text {
  font-size: 1rem;
  color: #858796;
  margin-bottom: 1rem;
  line-height: 1.5;
}

.alert {
  border-radius: var(--border-radius);
  padding: 1rem 1.25rem;
  margin-bottom: 1.5rem;
  border: none;
}

.alert-danger {
  background-color: #f8d7da;
  color: #721c24;
  border-left: 4px solid var(--danger-color);
}

.alert-icon {
  margin-right: 0.5rem;
}

.tooltip-icon {
  margin-left: 5px;
  font-size: 0.8rem;
  color: #858796;
  cursor: help;
}

/* モバイル対応のメディアクエリ */
@media (max-width: 768px) {
  .app-container {
    padding: 0.5rem;
  }
  
  .header-section {
    padding: 1rem;
    margin-bottom: 1rem;
  }
  
  h1 {
    font-size: 1.5rem;
  }
  
  .config-card {
    padding: 1rem;
    margin-bottom: 1rem;
  }
  
  .btn {
    width: 100%;
    margin-top: 0.5rem;
    padding: 0.875rem 1rem;
    font-size: 1rem;
  }
  
  .btn:first-child {
    margin-top: 1rem;
  }
  
  .results-header {
    padding: 0.75rem 1rem;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.75rem;
  }
  
  .results-header > div {
    width: 100%;
  }
  
  .results-header .badge {
    display: inline-block;
    margin-top: 0.5rem;
  }
  
  .table-container {
    padding: 0;
  }
  
  .table {
    font-size: 0.85rem;
    min-width: 550px;
  }
  
  .table thead th {
    padding: 0.5rem 0.25rem;
    font-size: 0.7rem;
  }
  
  .table tbody td {
    padding: 0.5rem 0.25rem;
  }
  
  .team-container {
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
  }
  
  .team-container.right {
    flex-direction: column;
    align-items: center;
  }
  
  .vs-badge {
    margin: 0.25rem 0;
    width: 25px;
    height: 25px;
    font-size: 0.6rem;
  }
  
  .stat-card {
    min-width: 100%;
    margin: 0.25rem 0;
  }
  
  .court-badge {
    font-size: 0.7rem;
    padding: 0.2rem 0.4rem;
  }
  
  .team-label {
    font-size: 0.75rem;
    padding: 0.2rem 0.4rem;
  }
  
  .call-checkbox {
    transform: scale(1.4);
  }
  
  .empty-state {
    padding: 1.5rem 0.5rem;
  }
  
  .empty-icon {
    font-size: 2.5rem;
  }
  
  .empty-text {
    font-size: 0.9rem;
  }
}

@media (max-width: 576px) {
  .app-container {
    padding: 0.25rem;
  }
  
  .header-section,
  .config-card {
    margin-left: 0.25rem;
    margin-right: 0.25rem;
  }
  
  .table {
    min-width: 400px;
    font-size: 0.8rem;
  }
  
  .table thead th {
    font-size: 0.65rem;
    padding: 0.4rem 0.2rem;
  }
  
  .table tbody td {
    padding: 0.4rem 0.2rem;
  }
  
  .team-label {
    font-size: 0.7rem;
  }
  
  .court-badge {
    font-size: 0.65rem;
  }
  
  .vs-badge {
    width: 22px;
    height: 22px;
    font-size: 0.55rem;
  }
  
  h1 {
    font-size: 1.3rem;
  }
  
  .form-label {
    font-size: 0.85rem;
  }
  
  .form-control {
    font-size: 0.9rem;
  }
}

/* 横向きスマートフォン対応 */
@media (max-width: 768px) and (orientation: landscape) {
  .app-container {
    padding: 0.5rem;
  }
  
  .header-section {
    padding: 0.75rem;
    margin-bottom: 0.75rem;
  }
  
  h1 {
    font-size: 1.4rem;
    margin-bottom: 0.5rem;
  }
  
  .config-card {
    padding: 0.75rem;
  }
  
  .empty-state {
    padding: 1rem 0.5rem;
  }
}

/* タッチデバイス用の調整 */
@media (hover: none) and (pointer: coarse) {
  .btn:hover {
    transform: none;
    box-shadow: none;
  }
  
  .config-card:hover {
    transform: none;
  }
  
  .table tbody tr:hover {
    background-color: transparent;
  }
  
  .call-checkbox {
    min-width: 16px;
    min-height: 16px;
  }
}

/* 高解像度ディスプレイ対応 */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .header-section::before {
    width: 6px;
  }
  
  h1::after {
    height: 3px;
  }
}
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>
  
  <div class="app-container container">
    <div class="header-section">
      <h1><i class="fas fa-table-tennis fa-sm"></i> Round Generator</h1>
      <p class="text-muted">テニス・バドミントンなどのラウンディングを効率的に生成するツール</p>
    </div>

    <div class="config-card">
      <h5 class="mb-3"><i class="fas fa-cog fa-sm"></i> 設定</h5>
      
      <!-- 入力フォーム -->
      <form id="configForm" class="row g-3 align-items-end">
        <div class="col-md-3 col-sm-6">
          <label for="inpPlayers" class="form-label">
            シングル人数
            <span class="tooltip-icon" title="個人参加者の人数">
              <i class="fas fa-question-circle"></i>
            </span>
          </label>
          <div class="input-group">
            <span class="input-group-text"><i class="fas fa-user"></i></span>
            <input type="number" class="form-control" id="inpPlayers" value="10" min="0">
          </div>
        </div>
        <div class="col-md-3 col-sm-6">
          <label for="inpTeams" class="form-label">
            固定ペア数
            <span class="tooltip-icon" title="既に組まれたペアの数">
              <i class="fas fa-question-circle"></i>
            </span>
          </label>
          <div class="input-group">
            <span class="input-group-text"><i class="fas fa-users"></i></span>
            <input type="number" class="form-control" id="inpTeams" value="0" min="0">
          </div>
        </div>
        <div class="col-md-3 col-sm-6">
          <label for="inpCourts" class="form-label">
            コート数
            <span class="tooltip-icon" title="利用可能なコート数">
              <i class="fas fa-question-circle"></i>
            </span>
          </label>
          <div class="input-group">
            <span class="input-group-text"><i class="fas fa-vector-square"></i></span>
            <input type="number" class="form-control" id="inpCourts" value="2" min="1">
          </div>
        </div>
        <div class="col-md-3 col-sm-6">
          <label for="inpRounds" class="form-label">
            最大ラウンド数
            <span class="tooltip-icon" title="生成する最大のラウンド数">
              <i class="fas fa-question-circle"></i>
            </span>
          </label>
          <div class="input-group">
            <span class="input-group-text"><i class="fas fa-repeat"></i></span>
            <input type="number" class="form-control" id="inpRounds" value="50" min="1">
          </div>
        </div>
        <div class="col-12 mt-4">
          <button type="button" id="btnGen" class="btn btn-primary">
            <i class="fas fa-play btn-icon"></i>ラウンド生成
          </button>
          <button type="button" id="btnReset" class="btn btn-secondary ms-md-2">
            <i class="fas fa-undo btn-icon"></i>チェック解除
          </button>
        </div>
      </form>
    </div>

    <!-- 結果表示エリア -->
    <div id="outputArea" class="mt-4">
      <div class="empty-state">
        <div class="empty-icon">
          <i class="fas fa-table-tennis"></i>
        </div>
        <div class="empty-text">
          「ラウンド生成」ボタンをクリックして、試合組み合わせを生成してください。
        </div>
        <button type="button" id="btnGuide" class="btn btn-outline-primary">
          <i class="fas fa-info-circle btn-icon"></i>使い方ガイド
        </button>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS (Popper+Bundle) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- ツールチップ初期化 -->
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const tooltips = document.querySelectorAll('[title]');
    tooltips.forEach(el => {
      new bootstrap.Tooltip(el);
    });
  });
  </script>
  <script>
  // 組み合わせ生成ユーティリティ
  function combinations(arr, k) {
    const result = [];
    const combo = (start, path) => {
      if (path.length === k) {
        result.push([...path]);
        return;
      }
      for (let i = start; i < arr.length; i++) {
        path.push(arr[i]);
        combo(i + 1, path);
        path.pop();
      }
    };
    combo(0, []);
    return result;
  }

  // Set/Array → 一意な文字列化（frozenset用途）
  function setKey(a) {
    return Array.from(a).sort((x, y) => x - y).join(',');
  }

  // 固定ペア用: 配列→hash値 (衝突しにくい値)
  function pairHash(pair) {
    return pair[0] * 1000 + pair[1];
  }

  class RoundGenerator {
    constructor(numPlayers, numCourts = 2, maxRounds = 100, numTeams = 0) {
      // 固定ペア生成
      this.fixedPairs = [];
      for (let i = 1; i <= numTeams * 2; i += 2) {
        this.fixedPairs.push([i, i + 1]);
      }
      this.fixedLabel = {};
      this.fixedPairs.forEach((pair, idx) => {
        this.fixedLabel[setKey(pair)] = String.fromCharCode(65 + idx);
      });

      this.fixedPairSets = this.fixedPairs.map(pair => new Set(pair));

      this.numPlayers = numPlayers + numTeams * 2;
      this.numCourts = numCourts;
      this.maxRounds = maxRounds;

      // 各プレイヤーの累積試合数
      this.player2matchnum = {};
      for (let p = 1; p <= this.numPlayers; p++) this.player2matchnum[p] = 0;

      this.usedGroups = new Set(); // setKey(group)
      this.usedTeams = new Set();  // setKey(team)

      // 対戦履歴（Map: setKey→回数）
      this.playerHistory = new Map();

      this.allPairings = this._enumeratePairings();
      this.rounds = [];
    }

    _isFixedPair(p1, p2) {
      // 固定ペアに一致するか
      return this.fixedPairSets.some(
        s => s.has(p1) && s.has(p2) && s.size === 2
      );
    }

    _enumeratePairings() {
      const players = Array.from({ length: this.numPlayers }, (_, i) => i + 1);
      const seen = new Set();
      const pairings = [];
      const fixedSets = this.fixedPairs.map(pair => new Set(pair));
      for (const four of combinations(players, 4)) {
        const fs4 = new Set(four);
        // 「固定ペアの一方だけ」混ざってる場合はスキップ
        let bad = false;
        for (const fset of fixedSets) {
          const intersection = [...fs4].filter(x => fset.has(x));
          if (intersection.length === 1) {
            bad = true;
            break;
          }
        }
        if (bad) continue;

        for (const t1 of combinations(four, 2)) {
          let ok = true;
          for (const fset of fixedSets) {
            if ([...fset].every(x => fs4.has(x))) {
              if ([...fset].filter(x => t1.includes(x)).length === 1) {
                ok = false;
                break;
              }
            }
          }
          if (!ok) continue;
          const team1 = [...t1].sort((a, b) => a - b);
          const team2 = [...four].filter(x => !team1.includes(x)).sort((a, b) => a - b);
          let t1n = team1, t2n = team2;
          // 辞書順normalize
          if (t1n[0] > t2n[0]) [t1n, t2n] = [t2n, t1n];
          const key = setKey([...t1n, ...t2n]);
          if (!seen.has(key)) {
            seen.add(key);
            pairings.push([new Set(four), [t1n, t2n]]);
          }
        }
      }
      return pairings;
    }

    _calculate_group_priority(group) {
      // group: Set
      const vals = Array.from(group).map(p => this.player2matchnum[p]);
      const min_matches = Math.min(...vals);
      const match_diff = Math.max(...vals) - min_matches;
      return [min_matches, match_diff];
    }

    _calculate_novelty_score(group, team1, team2) {
      let score = 0;
      // チーム内の組み合わせ（一緒にプレー）
      [team1, team2].forEach(t => {
        for (let i = 0; i < t.length; i++) {
          for (let j = i + 1; j < t.length; j++) {
            if (this._isFixedPair(t[i], t[j])) continue;
            const key = setKey([t[i], t[j]]);
            score += (this.playerHistory.get(key) || 0) * 20;
          }
        }
      });
      // チーム間の対戦履歴
      for (const p1 of team1) {
        for (const p2 of team2) {
          const key = setKey([p1, p2 + this.numPlayers]);
          score += (this.playerHistory.get(key) || 0) * 20;
        }
      }
      // 固定ペア同士の対戦履歴
      const team1_fixed_pairs = [];
      const team2_fixed_pairs = [];
      for (const fp of this.fixedPairs) {
        const fpSet = new Set(fp);
        if ([...fpSet].every(x => team1.includes(x))) team1_fixed_pairs.push(fp);
        if ([...fpSet].every(x => team2.includes(x))) team2_fixed_pairs.push(fp);
      }
      for (const fp1 of team1_fixed_pairs) {
        for (const fp2 of team2_fixed_pairs) {
          const key = setKey([pairHash(fp1), pairHash(fp2) + 1000]);
          score += (this.playerHistory.get(key) || 0) * 8;
        }
      }
      return score;
    }

    _select_for_round(prev_players, avoid_prev, avoid_team) {
      // prev_players: Set
      let cands = this.allPairings.filter(
        ([group]) => !this.usedGroups.has(setKey(group))
      );
      const picks = [];
      let used_in_round = new Set();

      for (let i = 0; i < this.numCourts; i++) {
        if (!cands.length) break;
        const valid_cands = [];
        for (const [group, [t1, t2]] of cands) {
          const groupArr = [...group];
          // 同ラウンド内重複
          if (groupArr.some(x => used_in_round.has(x))) continue;
          // 直前ラウンド重複
          if (avoid_prev && groupArr.some(x => prev_players.has(x))) continue;
          // ペア再利用
          if (avoid_team) {
            const team1_set = setKey(t1), team2_set = setKey(t2);
            if ((this.usedTeams.has(team1_set) && !this.fixedPairSets.some(fp => [...fp].every(x => t1.includes(x)))) ||
                (this.usedTeams.has(team2_set) && !this.fixedPairSets.some(fp => [...fp].every(x => t2.includes(x))))
            ) continue;
          }
          if (!this.fixedPairSets.some(fp => [...fp].every(x => t1.includes(x)))) {
            if ((this.playerHistory.get(setKey(t1)) || 0) > 0) continue;
          }
          if (!this.fixedPairSets.some(fp => [...fp].every(x => t2.includes(x)))) {
            if ((this.playerHistory.get(setKey(t2)) || 0) > 0) continue;
          }
          // グループ優先度
          const group_priority = this._calculate_group_priority(group);
          // 新しさスコア
          const novelty_score = this._calculate_novelty_score(group, t1, t2);
          valid_cands.push([group, [t1, t2], group_priority, novelty_score]);
        }
        // ソート
        valid_cands.sort((a, b) => {
          // チーム内ペア回数を最優先
          const pairCountA = (
            (this.playerHistory.get(setKey([a[1][0][0], a[1][0][1]])) || 0) +
            (this.playerHistory.get(setKey([a[1][1][0], a[1][1][1]])) || 0)
          );
          const pairCountB = (
            (this.playerHistory.get(setKey([b[1][0][0], b[1][0][1]])) || 0) +
            (this.playerHistory.get(setKey([b[1][1][0], b[1][1][1]])) || 0)
          );
          if (pairCountA !== pairCountB) return pairCountA - pairCountB;
          if (a[2][0] !== b[2][0]) return a[2][0] - b[2][0];
          if (a[2][1] !== b[2][1]) return a[2][1] - b[2][1];
          return a[3] - b[3];
        });
        if (!valid_cands.length) break;
        const [group, teams] = valid_cands[0];
        picks.push([group, teams]);
        used_in_round = new Set([...used_in_round, ...group]);
        cands = cands.filter(([g]) => ![...g].some(x => group.has(x)));
      }
      return [picks, used_in_round];
    }

    _update_player_history(team1, team2) {
      // チーム内
      [team1, team2].forEach(t => {
        for (let i = 0; i < t.length; i++) {
          for (let j = i + 1; j < t.length; j++) {
            if (this._isFixedPair(t[i], t[j])) continue;
            const key = setKey([t[i], t[j]]);
            this.playerHistory.set(key, (this.playerHistory.get(key) || 0) + 1);
          }
        }
      });
      // チーム間
      for (const p1 of team1) {
        for (const p2 of team2) {
          const key = setKey([p1, p2 + this.numPlayers]);
          this.playerHistory.set(key, (this.playerHistory.get(key) || 0) + 1);
        }
      }
      // 固定ペア同士
      const team1_fixed_pairs = [];
      const team2_fixed_pairs = [];
      for (const fp of this.fixedPairs) {
        const fpSet = new Set(fp);
        if ([...fpSet].every(x => team1.includes(x))) team1_fixed_pairs.push(fp);
        if ([...fpSet].every(x => team2.includes(x))) team2_fixed_pairs.push(fp);
      }
      for (const fp1 of team1_fixed_pairs) {
        for (const fp2 of team2_fixed_pairs) {
          const key = setKey([pairHash(fp1), pairHash(fp2) + 1000]);
          this.playerHistory.set(key, (this.playerHistory.get(key) || 0) + 1);
        }
      }
    }

    generate() {
      if (this.numPlayers < this.numCourts * 4)
        throw new Error("プレイヤー数が不足しています");
      let prev_players = new Set();

      for (let rnd = 0; rnd < this.maxRounds; rnd++) {
        const modes = [
          [true, true],
          [true, false],
          [false, true],
          [false, false],
        ];
        let picks, used_in_round, found = false;
        for (const [avoid_prev, avoid_team] of modes) {
          [picks, used_in_round] = this._select_for_round(prev_players, avoid_prev, avoid_team);
          if (picks.length === this.numCourts) {
            found = true;
            break;
          }
        }
        if (!found) break;

        const formatted = [];
        for (const [group, [t1, t2]] of picks) {
          this.usedGroups.add(setKey(group));
          const team1_set = setKey(t1), team2_set = setKey(t2);
          if (!this.fixedPairSets.some(fp => [...fp].every(x => t1.includes(x))))
            this.usedTeams.add(team1_set);
          if (!this.fixedPairSets.some(fp => [...fp].every(x => t2.includes(x))))
            this.usedTeams.add(team2_set);
          for (const p of group) this.player2matchnum[p] += 1;
          this._update_player_history(t1, t2);
          formatted.push([t1, t2]);
        }
        this.rounds.push(formatted);
        prev_players = used_in_round;
      }
      return this.rounds;
    }

    // 統計情報を取得
    getStats() {
      const playerMatches = Object.values(this.player2matchnum);
      const minMatches = Math.min(...playerMatches);
      const maxMatches = Math.max(...playerMatches);
      const avgMatches = playerMatches.reduce((a, b) => a + b, 0) / playerMatches.length;

      return {
        totalRounds: this.rounds.length,
        totalMatches: this.rounds.length * this.numCourts,
        minPlayerMatches: minMatches,
        maxPlayerMatches: maxMatches,
        avgPlayerMatches: avgMatches.toFixed(1),
        playerMatchDistribution: this._getMatchDistribution(),
      };
    }

    _getMatchDistribution() {
      // 試合数ごとの選手数を計算
      const distribution = {};
      Object.values(this.player2matchnum).forEach(count => {
        distribution[count] = (distribution[count] || 0) + 1;
      });

      // Chart.js用のデータ形式に変換
      const labels = [];
      const data = [];

      const maxCount = Math.max(...Object.keys(distribution).map(Number));
      for (let i = 0; i <= maxCount; i++) {
        labels.push(i.toString());
        data.push(distribution[i] || 0);
      }

      return { labels, data };
    }
  }

  // ==== DOM 操作 ====
  const btnGen    = document.getElementById('btnGen');
  const btnReset  = document.getElementById('btnReset');
  const output    = document.getElementById('outputArea');
  const loadingOverlay = document.getElementById('loadingOverlay');

  btnGen.addEventListener('click', ()=>{
    const s  = parseInt(document.getElementById('inpPlayers').value,10);
    const t  = parseInt(document.getElementById('inpTeams').value,10);
    const c  = parseInt(document.getElementById('inpCourts').value,10);
    const mr = parseInt(document.getElementById('inpRounds').value,10);

    // ローディング表示
    loadingOverlay.classList.add('show');
    
    // 非同期処理
    setTimeout(() => {
      output.innerHTML = '';
      
      try {
        const rg = new RoundGenerator(s, c, mr, t);
        const rounds = rg.generate();
        const stats = rg.getStats();
  
        // 固定ペアラベル A,B,C...
        const fixedLabel = {};
        rg.fixedPairs.forEach((pair, idx)=>{
          fixedLabel[pair.join(',')] = String.fromCharCode(65 + idx);
        });
        
        // 結果カードを作成
        const resultsCard = document.createElement('div');
        resultsCard.className = 'results-card';
        
        // カードヘッダー
        const resultsHeader = document.createElement('div');
        resultsHeader.className = 'results-header';
        resultsHeader.innerHTML = `
          <div>
            <i class="fas fa-trophy me-2"></i>
            生成結果: ${stats.totalRounds}ラウンド (${stats.totalMatches}試合)
          </div>
          <div>
            <span class="badge bg-light text-dark">
              <i class="fas fa-user me-1"></i>参加者: ${rg.numPlayers}人
            </span>
          </div>
        `;
        resultsCard.appendChild(resultsHeader);
        
        // テーブルコンテナ
        const tableContainer = document.createElement('div');
        tableContainer.className = 'table-container';
        
        const tbl = document.createElement('table');
        tbl.className = 'table table-hover';
        tbl.innerHTML = `
          <thead>
            <tr>
              <th style="width:100px;">完了</th>
              <!-- <th style="width:80px;">ラウンド</th> -->
              <th style="width:180px;">コート</th>
              <th class="text-end">Team 1</th>
              <th class="text-center" style="width:80px;">vs</th>
              <th class="text-start">Team 2</th>
            </tr>
          </thead>
          <tbody>
            ${rounds.map((matches, ri)=>{
              return matches.map((pair, ci)=>{
                const [t1,t2] = pair;
                const k1 = t1.join(','), k2 = t2.join(',');
                const l1 = fixedLabel[k1] || `${t1.map(p => `<div class="d-inline-block mx-2"><span class="badge bg-light text-dark fs-3">${p}</span></div>`).join('')}`;
                const l2 = fixedLabel[k2] || `${t2.map(p => `<div class="d-inline-block mx-2"><span class="badge bg-light text-dark fs-3">${p}</span></div>`).join('')}`;
                return `
                <tr>
                  <td><input type="checkbox" class="call-checkbox"></td>
                  <!-- <td><span class="round-badge">${ri+1}</span></td> -->
                  <td><span class="court-badge fs-4"><span class="d-none d-md-inline"><i class="fas fa-table-tennis me-1"></i>コート</span> ${ci+1}</span></td>
                  <td>
                    <div class="team-container">
                      <div class="team-label">${l1}</div>
                    </div>
                  </td>
                  <td class="text-center"><div class="vs-badge">VS</div></td>
                  <td>
                    <div class="team-container right">
                      <div class="team-label">${l2}</div>
                    </div>
                  </td>
                </tr>`;
              }).join('');
            }).join('')}
          </tbody>
        `;
        tableContainer.appendChild(tbl);
        resultsCard.appendChild(tableContainer);
        
        output.appendChild(resultsCard);
        
        // アニメーションでカードを表示
        setTimeout(() => {
          resultsCard.classList.add('show');
        }, 100);
        
        
        // チェックボックスイベント設定
        document.querySelectorAll('.call-checkbox').forEach(cb => {
          cb.addEventListener('change', function() {
            const row = this.closest('tr');
            if (this.checked) {
              row.classList.add('completed');
            } else {
              row.classList.remove('completed');
            }
          });
        });
        
      } catch(e) {
        const alert = document.createElement('div');
        alert.className = 'alert alert-danger';
        alert.innerHTML = `<i class="fas fa-exclamation-circle alert-icon"></i> エラー: ${e.message}`;
        output.appendChild(alert);
        
        // エラー時は空の状態を表示
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        emptyState.innerHTML = `
          <div class="empty-icon">
            <i class="fas fa-exclamation-triangle"></i>
          </div>
          <div class="empty-text">
            設定を見直して、もう一度試してください。
          </div>
        `;
        output.appendChild(emptyState);
      }
      
      // ローディング非表示
      loadingOverlay.classList.remove('show');
      
    }, 800); // 処理遅延時間（アニメーション用）
  });

  btnReset.addEventListener('click', ()=>{
    document.querySelectorAll('.call-checkbox')
            .forEach(cb => {
              cb.checked = false;
              const row = cb.closest('tr');
              if (row) row.classList.remove('completed');
            });
  });
  
  // 使い方ガイド
  document.getElementById('btnGuide').addEventListener('click', () => {
    const guideHTML = `
      <div class="modal fade" id="guideModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
          <div class="modal-content">
            <div class="modal-header bg-primary text-white">
              <h5 class="modal-title"><i class="fas fa-book me-2"></i>Round Generator 使い方ガイド</h5>
              <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <div class="row">
                <div class="col-md-6">
                  <h6><i class="fas fa-cog me-2"></i>基本設定</h6>
                  <ul class="list-group list-group-flush mb-4">
                    <li class="list-group-item"><strong>シングル人数</strong>: 個人参加者の人数</li>
                    <li class="list-group-item"><strong>固定ペア数</strong>: 既に組まれたペアの数</li>
                    <li class="list-group-item"><strong>コート数</strong>: 利用可能なコート数</li>
                    <li class="list-group-item"><strong>最大ラウンド数</strong>: 生成するラウンドの上限</li>
                  </ul>
                </div>
                <div class="col-md-6">
                  <h6><i class="fas fa-lightbulb me-2"></i>ヒント</h6>
                  <ul class="list-group list-group-flush mb-4">
                    <li class="list-group-item">総プレイヤー数はコート数×4以上必要です</li>
                    <li class="list-group-item">固定ペアは常にペアを組みます</li>
                    <li class="list-group-item">チェックボックスで試合完了状態を管理できます</li>
                  </ul>
                </div>
              </div>
              
              <div class="alert alert-info mt-3">
                <i class="fas fa-info-circle me-2"></i>
                このツールは、すべての参加者が均等に試合に参加できるよう最適化されています。
                固定ペアは常にペアを組み、シングル参加者は様々な相手と組み合わされます。
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-primary" data-bs-dismiss="modal">理解しました</button>
            </div>
          </div>
        </div>
      </div>
    `;
    
    // モーダルをDOMに追加して表示
    document.body.insertAdjacentHTML('beforeend', guideHTML);
    const modal = new bootstrap.Modal(document.getElementById('guideModal'));
    modal.show();
    
    // モーダルが閉じられたときにDOMから削除
    document.getElementById('guideModal').addEventListener('hidden.bs.modal', function () {
      this.remove();
    });
  });
  </script>
</body>
</html>